import numpy as np
from scan.common.math import gray_code, bit_array
import cv2

class StaticPattern:
    """
    Class: StaticPattern
    A pattern class to be used for the turning on and off of static projectors,
    most likely implemented as a grid over an LED. This pattern has no
    information other than type, as static projectors can only create a single
    pattern.
    """
    pass

class DLPPattern:
    """
    Class: DLPPattern
    A pattern class to be used for the display of arbitrary patterns on DLP
    projectors. This class contains a matrix that represents the pixel values to
    be projected. This matrix is set at construction and used by DLP projectors
    to create a similar projected pattern.

    Properties:
    image - the image matrix that defines this projection
    """
    def __init__(self, image):
        self.image = image

def gray_code_patterns(img_shape, vertical_stripes=True):
    """
    Function: gray_code_patterns
    Generates a list of <DLPPattern> objects corresponding to a sequence of
    Gray codes to be projected. Each Gray code pattern will be repeated with
    its colors inverted. The first pattern will have the first half be all
    white and the second half all black, and the second pattern will have the
    first half be all black and the second half be all white

    Parameters:
    img_shape - *Tuple* of form (width, height), where width is the pixel width
    of the pattern and height is the pixel height of the pattern
    vertical_stripes - *boolean* If true, generate stripes going up and down,
    otherwise, generate horizontal stripes

    Returns:
    *[<DLPPattern>]* list of patterns for the Gray code
    """
    # see if going by width or height
    dim_idx = int(not vertical_stripes)
    other_dim_idx = int(vertical_stripes)

    # get parameters for generation
    n = np.ceil(np.log2(img_shape[dim_idx]))
    offset = np.floor((2**n - img_shape[dim_idx]) / 2)

    # list of Gray code numbers
    gray_nums = gray_code(np.arange(2**n, dtype='i'))

    # convert to bit arrays
    gray_bits = bit_array(gray_nums)

    # function to generate pixels from gray_code_line
    def gen_pixels(line):
        pixels = np.tile(line, ((img_shape[other_dim_idx], 1)))
        if vertical_stripes:
            pixels = pixels.T
        return pixels

    # create the pattern sequence
    patterns = []
    for i in range(gray_bits.shape[1]):
        bit_seq = gray_bits[:,i]
        patterns.append(DLPPattern(gen_pixels(bit_seq * 255)))
        patterns.append(DLPPattern(
                gen_pixels(np.logical_not(bit_seq).astype('i') * 255)))

    return patterns

def are_inverses(pattern_1, pattern_2):
    """
    Function: are_inverses
    Tests whether two black-and-white <DLPPattern>s are inverses of each
    other.  This means that one pattern is black where the other is white,
    and visa versa

    Parameters:
    pattern_1 - *<DLPPattern>* black-and-white pattern to compare against pattern 1
    pattern_2 - *<DLPPattern>* black-and-white pattern to compare against pattern 2

    Returns:
    *bool* True or False.
    """
    if not (issubclass(pattern_1.__class__, DLPPattern) and
            issubclass(pattern_2.__class__, DLPPattern)):
        raise Exception("Patterns must be subclasses of DLPPattern")

    largest_val = np.max([pattern_1.image.max(), pattern_2.image.max()])

    img_1 = pattern_1.image / largest_val
    img_2 = pattern_2.image / largest_val

    if (img_1.max() not in [0, 1]) or (img_2.max() not in [0, 1]):
        raise Exception("It seems like the two patterns aren't using the same scale " +
                        "(i.e., pixel values aren't equivalent). " +
                        "Cannot reliable compare them")

    return np.all(np.bitwise_xor(img_1, img_2))

def pattern_to_RGB(pattern):
    """
    Function: pattern_to_RGB
    Takes a grayscale pattern and converts it to an RGB *ndarray*

    Parameters:
    pattern - *<DLPPattern>* or *ndarray* grayscale pattern to convert to a color array

    Returns:
    *ndarray* Pattern as RGB image data
    """
    if issubclass(pattern.__class__, DLPPattern):
        pattern = pattern.image

    pattern = np.array(pattern)

    if len(pattern.shape) > 2 and not (len(pattern.shape) == 3 and pattern.shape[2] == 1):
        raise Exception("pattern does not represent a valid grayscale pattern")

    return cv2.cvtColor(pattern.astype(np.uint8), cv2.COLOR_GRAY2RGB)

class GeneratedPattern:
    """
    Class: GeneratedPattern
    This class represents the light field generated by a projector. It factors in
    the distortion and calibration of the projector in its image, and takes into
    account multiple projectors, if multiple projectors are used. It also
    contains a reference to the projectors that created the pattern for easy
    access later on.

    Attributes:
    projected_patterns - *[(<Pattern>, <Projector>)]* List of pattern, projector
    tuples telling what patterns where being projected by which projectors
    """
    def __init__(self, projected_patterns):
        self.projected_patterns = projected_patterns
